generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  // Use a direct (non-pooling) connection for Prisma migrations/introspection.
  // On Vercel/Neon this is typically provided as DATABASE_URL_UNPOOLED / POSTGRES_URL_NON_POOLING.
  directUrl = env("DATABASE_URL_UNPOOLED")
}

model User {
  id                 String            @id @default(cuid())
  name               String?
  email              String?           @unique
  emailVerified      DateTime?
  image              String?
  passwordHash       String?           @db.Text
  mustChangePassword Boolean           @default(false)
  disabled           Boolean           @default(false)
  isAdmin            Boolean           @default(false)
  bio                String?           @db.Text
  bilibili           String?
  weibo              String?
  github             String?
  twitter            String?
  createdAt          DateTime          @default(now())
  accounts           Account[]
  sessions           Session[]
  submissions        Submission[]
  articles           Article[]
  articleRevisions   ArticleRevision[]
  assets             Asset[]
  favorites          Favorite[]
  mdxFavorites       MdxFavorite[]
  waitlistEntry      WaitlistEntry?
  comments           Comment[]
  commentLikes       CommentLike[]
  translationHistories TranslationHistory[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model EmailOtp {
  id        String    @id @default(cuid())
  email     String
  codeHash  String    @db.Text
  salt      String    @db.Text
  ipHash    String?
  attempts  Int       @default(0)
  createdAt DateTime  @default(now())
  expiresAt DateTime
  usedAt    DateTime?

  @@index([email, createdAt])
  @@index([expiresAt])
}

model Submission {
  id              String           @id @default(cuid())
  userId          String
  title           String
  animeName       String
  city            String
  cities          SubmissionCity[]
  contentMarkdown String
  references      String?
  status          String           @default("pending")
  ipHash          String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Admin {
  email  String  @id
  active Boolean @default(true)
}

model Article {
  id                 String        @id @default(cuid())
  authorId           String
  slug               String
  language           String        @default("zh")
  translationGroupId String?
  title              String
  seoTitle           String?       @db.Text
  description        String?       @db.Text
  animeIds           String[]      @default([])
  city               String?
  cities             ArticleCity[]
  routeLength        String?
  tags               String[]      @default([])
  cover              String?
  contentJson        Json?
  contentHtml        String        @default("") @db.Text
  status             String        @default("draft")
  rejectReason       String?       @db.Text
  needsRevision      Boolean       @default(false)
  publishedAt        DateTime?
  lastApprovedAt     DateTime?
  favorites          Favorite[]
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  author    User              @relation(fields: [authorId], references: [id], onDelete: Cascade)
  revisions ArticleRevision[]

  @@unique([slug, language])
  @@index([authorId])
  @@index([status])
  @@index([status, updatedAt])
  @@index([translationGroupId])
}

model Favorite {
  userId    String
  articleId String
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  article Article @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@id([userId, articleId])
  @@index([userId])
  @@index([articleId])
}

model MdxFavorite {
  userId    String
  slug      String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, slug])
  @@index([userId])
}

model WaitlistEntry {
  id        String   @id @default(cuid())
  userId    String   @unique
  email     String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([createdAt])
}

model ArticleRevision {
  id                 String                @id @default(cuid())
  articleId          String
  authorId           String
  language           String                @default("zh")
  translationGroupId String?
  title              String
  seoTitle           String?               @db.Text
  description        String?               @db.Text
  animeIds           String[]              @default([])
  city               String?
  cities             ArticleRevisionCity[]
  routeLength        String?
  tags               String[]              @default([])
  cover              String?
  contentJson        Json?
  contentHtml        String                @default("") @db.Text
  status             String                @default("draft")
  activeKey          String?
  rejectReason       String?               @db.Text
  createdAt          DateTime              @default(now())
  updatedAt          DateTime              @updatedAt

  article Article @relation(fields: [articleId], references: [id], onDelete: Cascade)
  author  User    @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@unique([articleId, activeKey])
  @@index([articleId])
  @@index([authorId])
  @@index([status])
  @@index([status, updatedAt])
  @@index([translationGroupId])
}

model Anime {
  id         String   @id
  name       String
  alias      String[] @default([])
  year       Int?
  summary    String?
  cover      String?
  hidden     Boolean  @default(false)
  name_en    String?
  name_ja    String?
  summary_en String?
  summary_ja String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Asset {
  id          String   @id @default(cuid())
  ownerId     String
  contentType String
  filename    String?
  bytes       Bytes
  createdAt   DateTime @default(now())

  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  @@index([ownerId])
}

model City {
  id               String   @id @default(cuid())
  slug             String   @unique
  name_zh          String
  name_en          String?
  name_ja          String?
  description_zh   String?  @db.Text
  description_en   String?  @db.Text
  transportTips_zh String?  @db.Text
  transportTips_en String?  @db.Text
  description_ja   String?  @db.Text
  transportTips_ja String?  @db.Text
  cover            String?
  needsReview      Boolean  @default(true)
  hidden           Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  aliases         CityAlias[]
  articleLinks    ArticleCity[]
  revisionLinks   ArticleRevisionCity[]
  submissionLinks SubmissionCity[]
  redirectsToMe   CityRedirect[]        @relation("CityRedirectTo")
}

model CityAlias {
  id        String  @id @default(cuid())
  cityId    String
  alias     String
  aliasNorm String
  langCode  String?
  isPrimary Boolean @default(false)

  city City @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@unique([aliasNorm])
  @@index([aliasNorm])
  @@index([cityId])
}

model CityRedirect {
  fromSlug String @id
  toCityId String

  toCity City @relation("CityRedirectTo", fields: [toCityId], references: [id], onDelete: Cascade)

  @@index([toCityId])
}

model ArticleCity {
  articleId String
  cityId    String

  article Article @relation(fields: [articleId], references: [id], onDelete: Cascade)
  city    City    @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@id([articleId, cityId])
  @@index([cityId])
}

model ArticleRevisionCity {
  revisionId String
  cityId     String

  revision ArticleRevision @relation(fields: [revisionId], references: [id], onDelete: Cascade)
  city     City            @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@id([revisionId, cityId])
  @@index([cityId])
}

model SubmissionCity {
  submissionId String
  cityId       String

  submission Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  city       City       @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@id([submissionId, cityId])
  @@index([cityId])
}

model Comment {
  id          String   @id @default(cuid())
  articleId   String?
  mdxSlug     String?
  authorId    String
  parentId    String?
  content     String   @db.Text
  contentHtml String   @db.Text
  createdAt   DateTime @default(now())

  author  User          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent  Comment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies Comment[]     @relation("CommentReplies")
  likes   CommentLike[]

  @@index([articleId])
  @@index([mdxSlug])
  @@index([authorId])
}

model CommentLike {
  userId    String
  commentId String
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@id([userId, commentId])
  @@index([commentId])
}

model TranslationTask {
  id             String               @id @default(cuid())
  entityType     String
  entityId       String
  targetLanguage String
  status         String               @default("pending")
  sourceContent  Json?
  draftContent   Json?
  finalContent   Json?
  error          String?              @db.Text
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  histories      TranslationHistory[]

  @@unique([entityType, entityId, targetLanguage])
  @@index([status])
  @@index([status, updatedAt])
  @@index([entityType, status])
  @@index([entityType, targetLanguage, status, updatedAt])
}

model TranslationHistory {
  id                String   @id @default(cuid())
  translationTaskId String
  articleId         String
  content           Json
  createdAt         DateTime @default(now())
  createdById       String

  translationTask TranslationTask @relation(fields: [translationTaskId], references: [id], onDelete: Cascade)
  createdBy       User            @relation(fields: [createdById], references: [id], onDelete: Cascade)

  @@index([translationTaskId])
  @@index([articleId])
  @@index([createdAt])
}

model SeoKeyword {
  id          String            @id @default(cuid())
  keyword     String
  language    String
  category    String
  priority    Int               @default(0)
  isActive    Boolean           @default(true)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  rankHistory SeoRankHistory[]
}

model SeoRankHistory {
  id        String    @id @default(cuid())
  keywordId String
  position  Int?
  url       String?
  checkedAt DateTime  @default(now())
  source    String

  keyword SeoKeyword @relation(fields: [keywordId], references: [id], onDelete: Cascade)

  @@index([keywordId])
}

model SeoGscData {
  id          String   @id @default(cuid())
  query       String
  page        String
  clicks      Int
  impressions Int
  ctr         Float
  position    Float
  date        DateTime
  createdAt   DateTime @default(now())

  @@unique([query, page, date])
}

model SeoApiUsage {
  id        String   @id @default(cuid())
  provider  String
  date      String
  count     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([provider, date])
}

model OpsReport {
  id               String       @id @default(cuid())
  source           String
  windowStart      DateTime
  windowEnd        DateTime
  dateKey          String
  triggerMode      String
  status           String
  totalDeployments Int
  totalLogs        Int
  severeCount      Int
  warningCount     Int
  truncated        Boolean      @default(false)
  markdownSummary  String       @db.Text
  rawSummary       Json?
  createdAt        DateTime     @default(now())
  events           OpsLogEvent[]

  @@index([createdAt, dateKey])
}

model OpsLogEvent {
  id           String    @id @default(cuid())
  reportId     String
  severity     String
  fingerprint  String
  timestamp    DateTime?
  deploymentId String?
  requestId    String?
  path         String?
  method       String?
  statusCode   Int?
  message      String    @db.Text
  raw          Json?
  createdAt    DateTime  @default(now())
  report       OpsReport @relation(fields: [reportId], references: [id], onDelete: Cascade)

  @@index([reportId, severity, timestamp, fingerprint])
}
